#! /usr/bin/python -E
# Authors: Petr Viktorin <pviktori@redhat.com>
#
# Copyright (C) 2012  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

from ipaserver.install.ipa_replica_prepare import ReplicaPrepare

ReplicaPrepare.run_cli()


###################################################################################
exit()

import shutil, pwd
from ipapython.ipa_log_manager import *
import traceback
from ConfigParser import SafeConfigParser
import krbV

from ipapython import ipautil
from ipaserver.install import dsinstance
from ipaserver.install.bindinstance import add_zone, add_fwd_rr, add_ptr_rr
from ipaserver.install.installutils import resolve_host, BadHostError, HostLookupError
from ipapython import version
from ipalib import util

def export_certdb(realm_name, ds_dir, dir, passwd_fname, fname, hostname, subject_base=None, is_kdc=False):
    """realm is the kerberos realm for the IPA server.
       ds_dir is the location of the master DS we are creating a replica for.
       dir is the location of the files for the replica we are creating.
       passwd_fname is the file containing the PKCS#12 password
       fname is the filename of the PKCS#12 file for this cert (minus the .p12).
       hostname is the FQDN of the server we're creating a cert for.

       The subject is handled by certs.CertDB:create_server_cert()
    """

    if is_kdc:
        nickname = "KDC-Cert"
    else:
        nickname = "Server-Cert"

    try:
        self_signed = certs.ipa_self_signed()

        db = certs.CertDB(realm_name, nssdir=dir, subject_base=subject_base)
        db.create_passwd_file()
        ca_db = certs.CertDB(realm_name, host_name=api.env.host, subject_base=subject_base)
        if is_kdc:
            ca_db.create_kdc_cert("KDC-Cert", hostname, dir)
        else:
            db.create_from_cacert(ca_db.cacert_fname)
            db.create_server_cert(nickname, hostname, ca_db)
    except Exception, e:
        raise e

    pkcs12_fname = dir + "/" + fname + ".p12"

    try:
        if is_kdc:
            ca_db.export_pem_p12(pkcs12_fname, passwd_fname,
                                 nickname, dir + "/kdc.pem")
        else:
            db.export_pkcs12(pkcs12_fname, passwd_fname, nickname)
    except ipautil.CalledProcessError, e:
        print "error exporting Server certificate: " + str(e)
        remove_file(pkcs12_fname)
        remove_file(passwd_fname)

    remove_file(dir + "/cert8.db")
    remove_file(dir + "/key3.db")
    remove_file(dir + "/secmod.db")
    remove_file(dir + "/noise.txt")
    if is_kdc:
        remove_file(dir + "/kdc.pem")
    if ipautil.file_exists(passwd_fname + ".orig"):
        remove_file(passwd_fname + ".orig")

def export_ra_pkcs12(dir, dm_password):
    """
       dir is the location of the files for the replica we are creating.
       dm_password is the Directory Manager password

       If this install is using dogtag/RHCS then export the RA certificate.
    """
    if certs.ipa_self_signed():
        return

    (agent_fd, agent_name) = tempfile.mkstemp()
    os.write(agent_fd, dm_password)
    os.close(agent_fd)

    try:
        try:
            db = certs.CertDB(api.env.realm, host_name=api.env.host)

            if db.has_nickname("ipaCert"):
                pkcs12_fname = "%s/ra.p12" % dir
                db.export_pkcs12(pkcs12_fname, agent_name, "ipaCert")
        except Exception, e:
            raise e
    finally:
        os.remove(agent_name)

def save_config(dir, realm_name, host_name,
                domain_name, dest_host,
                subject_base):
    config = SafeConfigParser()
    config.add_section("realm")
    config.set("realm", "realm_name", realm_name)
    config.set("realm", "master_host_name", host_name)
    config.set("realm", "domain_name", domain_name)
    config.set("realm", "destination_host", dest_host)
    config.set("realm", "subject_base", str(subject_base))
    config.set("realm", "version", str(version.NUM_VERSION))
    with open(dir + "/realm_info", "w") as fd:
        config.write(fd)

def remove_file(fname, ignore_errors=True):
    try:
        os.remove(fname)
    except OSError, e:
        if not ignore_errors:
            raise e

def copy_files(realm_name, dir):
    config_dir = dsinstance.config_dirname(dsinstance.realm_to_serverid(realm_name))

    try:
        shutil.copy("/usr/share/ipa/html/ca.crt", dir + "/ca.crt")
        if ipautil.file_exists("/usr/share/ipa/html/preferences.html"):
            shutil.copy("/usr/share/ipa/html/krb.js", dir + "/krb.js")
            shutil.copy("/usr/share/ipa/html/kerberosauth.xpi", dir + "/kerberosauth.xpi")
            shutil.copy("/usr/share/ipa/html/preferences.html", dir + "/preferences.html")
            shutil.copy("/usr/share/ipa/html/configure.jar", dir + "/configure.jar")
        if ipautil.file_exists("/var/kerberos/krb5kdc/cacert.pem"):
            shutil.copy("/var/kerberos/krb5kdc/cacert.pem", dir + "/cacert.pem")
    except Exception, e:
        print "error copying files: " + str(e)
        sys.exit(1)


def main():

    if options.dirsrv_pkcs12:
        print "Copying SSL certificate for the Directory Server from %s" % options.dirsrv_pkcs12
        try:
            shutil.copy(options.dirsrv_pkcs12, dir + "/dscert.p12")
        except IOError, e:
            print "Copy failed %s" %  e
            sys.exit(1)
    else:
        try:
            if not certs.ipa_self_signed():
                if ipautil.file_exists(options.ca_file):
                    shutil.copy(options.ca_file, dir + "/cacert.p12")
                else:
                    raise RuntimeError("Root CA PKCS#12 not found in %s" % options.ca_file)
        except IOError, e:
            print "Copy failed %s" %  e
            sys.exit(1)
        print "Creating SSL certificate for the Directory Server"
        try:
            export_certdb(api.env.realm, ds_dir, dir, passwd_fname, "dscert", replica_fqdn, subject_base)
        except errors.CertificateOperationError, e:
            print "%s" % e
            sys.exit(1)

    if not certs.ipa_self_signed():
        print "Creating SSL certificate for the dogtag Directory Server"
        try:
            export_certdb(api.env.realm, ds_dir, dir, passwd_fname, "dogtagcert", replica_fqdn, subject_base)
        except errors.CertificateOperationError, e:
            print "%s" % e
            sys.exit(1)
        print "Saving dogtag Directory Server port"
        port_fname = dir + "/dogtag_directory_port.txt"
        with open(port_fname, "w") as fd:
            fd.write("%s\n" % str(dogtag.configured_constants().DS_PORT))

    if options.http_pin:
        passwd = options.http_pin
    else:
        passwd = ""

    passwd_fname = dir + "/http_pin.txt"
    fd = open(passwd_fname, "w")
    fd.write("%s\n" % passwd)
    fd.close()

    if options.http_pkcs12:
        print "Copying SSL certificate for the Web Server from %s" % options.http_pkcs12
        try:
            shutil.copy(options.http_pkcs12, dir + "/httpcert.p12")
        except IOError, e:
            print "Copy failed %s" %  e
            sys.exit(1)
    else:
        print "Creating SSL certificate for the Web Server"
        try:
            export_certdb(api.env.realm, ds_dir, dir, passwd_fname, "httpcert", replica_fqdn, subject_base)
        except errors.CertificateOperationError, e:
            print "%s" % e
            sys.exit(1)
        print "Exporting RA certificate"
        export_ra_pkcs12(dir, dirman_password)

    if options.setup_pkinit:
        if options.pkinit_pin:
            passwd = options.pkinit_pin
        else:
            passwd = ""

        passwd_fname = dir + "/pkinit_pin.txt"
        fd = open(passwd_fname, "w")
        fd.write("%s\n" % passwd)
        fd.close()

        if options.pkinit_pkcs12:
            print "Copying SSL certificate for the KDC from %s" % options.pkinit_pkcs12
            try:
                shutil.copy(options.pkinit_pkcs12, dir + "/pkinitcert.p12")
            except IOError, e:
                print "Copy failed %s" %  e
                sys.exit(1)
        else:
            print "Creating SSL certificate for the KDC"
            try:
                export_certdb(api.env.realm, ds_dir, dir,
                              passwd_fname, "pkinitcert",
                              replica_fqdn, subject_base,
                              is_kdc=True)
            except errors.CertificateOperationError, e:
                print "%s" % e
                sys.exit(1)

    print "Copying additional files"
    copy_files(api.env.realm, dir)
    print "Finalizing configuration"
    save_config(dir, api.env.realm, api.env.host, api.env.domain, replica_fqdn, subject_base)

    replicafile = "/var/lib/ipa/replica-info-" + replica_fqdn
    encfile = replicafile+".gpg"

    print "Packaging replica information into %s" % encfile
    ipautil.run(["/bin/tar", "cf", replicafile, "-C", top_dir, "realm_info"])
    ipautil.encrypt_file(replicafile, encfile, dirman_password, top_dir)

    os.chmod(encfile, 0600)

    remove_file(replicafile)
    shutil.rmtree(dir)

    if options.ip_address:
        print "Adding DNS records for %s" % replica_fqdn
        api.Backend.ldap2.connect(bind_dn=DN(('cn', 'Directory Manager')), bind_pw=dirman_password)

        domain = replica_fqdn.split(".")
        name = domain.pop(0)
        domain = ".".join(domain)

        ip = options.ip_address
        ip_address = str(ip)

        if options.reverse_zone:
            reverse_zone = bindinstance.normalize_zone(options.reverse_zone)
        else:
            reverse_zone = bindinstance.find_reverse_zone(ip)
            if reverse_zone is None and not options.no_reverse:
                reverse_zone = bindinstance.get_reverse_zone_default(ip)

        try:
            add_zone(domain)
        except errors.PublicError, e:
            sys.exit("Could not create forward DNS zone for the replica: %s" % e)

        try:
            add_fwd_rr(domain, name, ip_address)
        except errors.PublicError, e:
            sys.exit("Could not add forward DNS record for the replica: %s" % e)

        if reverse_zone is not None:
            print "Using reverse zone %s" % reverse_zone
            try:
                add_zone(reverse_zone)
            except errors.PublicError, e:
                sys.exit("Could not create reverse DNS zone for the replica: %s" % e)
            try:
                add_ptr_rr(reverse_zone, ip_address, replica_fqdn)
            except errors.PublicError, e:
                sys.exit("Could not add reverse DNS record for the replica: %s" % e)
